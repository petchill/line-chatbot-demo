let express,from,of,Subject,tap,take,mergeMap,retryWhen,map,R,bodyParser,axios,liffRouter;_af2‍.x([["default",()=>_af2‍.o]]);_af2‍.w("express",[["default",["express"],function(v){express=v}]]);_af2‍.w("rxjs",[["from",["from"],function(v){from=v}],["of",["of"],function(v){of=v}],["Subject",["Subject"],function(v){Subject=v}]]);_af2‍.w("rxjs/operators",[["tap",["tap"],function(v){tap=v}],["take",["take"],function(v){take=v}],["mergeMap",["mergeMap"],function(v){mergeMap=v}],["retryWhen",["retryWhen"],function(v){retryWhen=v}],["map",["map"],function(v){map=v}]]);_af2‍.w("ramda",[["default",["R"],function(v){R=v}]]);_af2‍.w("body-parser",[["default",["bodyParser"],function(v){bodyParser=v}]]);_af2‍.w("axios",[["default",["axios"],function(v){axios=v}]]);_af2‍.w("./liffRouter",[["router",["liffRouter"],function(v){liffRouter=v}]]);






const app = express()
const channelToken = "pkiErMEWSLofSNCkAEjIJUOL10SpPbRbA426Cf3ESvFM1vbcVmbl5Db87V5KS/l3/YBDXdBd5AHVOKvBgDncKRmIek+dYNzQ8W6gGgOusUcIFH73rKdvVjrr6bD8tyd4YPtRRUYuhyH6d16Bi1W/wAdB04t89/1O/w1cDnyilFU="
const lineReplyUrl = "https://api.line.me/v2/bot/message/reply"

const port = process.env.POST || 4002;
_af2‍.g.console.log(process.env.LINE_CHANNEL_TOKEN)
app.use(bodyParser.urlencoded({ extended: false }))
app.use(bodyParser.json())


const flexMessage = {
  type: 'flex',
  altText: 'This is a flex message'
  
}
const sendLine$ = async (data) => {
  const payload = R.prop('output', data)
  _af2‍.g.console.log('payload => ', JSON.stringify(payload, null, 2))
  const option = {
    headers: {
      "content-type": "application/json",
      "authorization": `Bearer ${process.env.LINE_CHANNEL_TOKEN}`
    }
  }
  try{
    const res = await axios.post(lineReplyUrl, payload, option)
  } catch (error) {
    _af2‍.g.console.error(error.response)
  }
}

// const sendMessage = R.compose(
//   // R.prop('output'),
//   map((payload) => {
//     console.log('payload => ', payload)
//     console.log('channel token => ', channelToken)
//   })
// )

const addInput = R.applySpec({
  input: R.identity()
})

const formatInput = (data) => {
  const destination = data.destination || undefined
  const result = from(R.prop('events', data)).pipe(
    tap(x => _af2‍.g.console.log("data 2 => ", x)),
    map(R.assoc('destination', destination)),
    map(addInput),
  )
  return result
}

const outputTranformation = () => (x) => {
  _af2‍.g.console.log('imput 0 => ', input)
  return {
    result: input
  }
}

const genOutputPayload = (x) => R.compose(
  R.assoc('output', {
    replyToken: x.input.replyToken,
    messages: [
      {
        type: 'text',
        text: x.input.message.text
      }
    ]
  }),
)(x)

const getType = (x) => x

const initiateOutput = R.compose(
  (x) => genOutputPayload(x),
  R.assoc('output', { type: '', message: [] })
)

const genPayload = R.pipe(
  formatInput,
  map(initiateOutput),
  tap(x => _af2‍.g.console.log('format => ', x)),
)



const line$ = new Subject()
line$.pipe(
  tap(x => _af2‍.g.console.log('tap => ', x)),
  mergeMap(genPayload),
  mergeMap(sendLine$)
).subscribe()

app.post('/webhook/line', (req, res) => {
  _af2‍.g.console.log("reqBody => ", JSON.stringify(req.body, null, 2))
  line$.next(req.body)
  res.send({})
})

app.use('/liff', liffRouter)

app.listen(port, () => _af2‍.g.console.log('app listening on port => ', port));

_af2‍.d(app);
